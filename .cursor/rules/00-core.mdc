---
description: "Chainfall monorepo core rules: structure, naming, TS conventions, workflow guardrails. Always apply."
globs:
alwaysApply: true
---

# Chainfall — Core Rules (Monorepo)

## 0) North Star

- Prefer **simple, readable, boring** solutions that are easy to debug.
- Do not introduce abstractions unless they remove real duplication or unlock a clear next step.
- If a change can be done in <50 LOC without a new layer, do that.

---

## 1) Repo layout contract (keep stable)

Target structure (kebab-case only):

.
├─ apps/
│ ├─ web-canvas/ # React + Canvas client (v1)
│ ├─ web-phaser/ # Phaser client (practice)
│ ├─ web-three/ # Three.js client (practice)
│ └─ server/ # NestJS API + WS
├─ packages/
│ ├─ game-core/ # deterministic pure game logic (no IO)
│ ├─ protocol/ # shared contracts/schemas/event types
│ └─ ui/ # optional shared UI bits (only if needed)
└─ tooling/ # optional scripts/configs (only if needed)

Rules:

- Do not create new top-level folders without a strong reason.
- UI never imports from server. Shared code goes in `packages/*`.
- Clients must stay thin renderers; rules/state transitions belong in `packages/game-core`.

---

## 2) Naming + filesystem rules

- All files/folders: **kebab-case**.
- Keep names **short and self-explaining** (no essay-names).
- Prefer `thing.service.ts`, `match.gateway.ts`, `game-state.ts`, etc.

---

## 3) TypeScript conventions

- Prefer `interface` over `type` (NOT a hard rule).
- All interfaces must start with capital `I` (e.g. `IGameState`). Type aliases: no `T` prefix—use concept name (e.g. `Player`, `GameState`).
- Avoid `enum`. Prefer `as const` objects + derived union types.
- Centralize typed values: define `const X = {...} as const`, derive type in the **same file** right after (e.g. `type X = ValueOf<typeof X>` or concept name). Use the const everywhere (types, schemas, runtime)—no magic strings for discriminants.
- Schema naming (Zod): PascalCase, same name for schema and inferred type (e.g. `Coord`), no `"Schema"` suffix. `import { Coord }` = schema, `import type { Coord }` = type.

---

## 4) Utilities + helpers

- Prefer grouping shared utils as **static classes** (readability):
  - `class TimeUtils { static msToSec(...) {} }`
- Exception: server-side NestJS “utils” that need DI should be injectable services.

---

## 5) Code organization + file size

- Aim for <500 lines per file. Split by category when it grows.
- Feature folders should look like:
  - `index.ts` (barrel exports)
  - `types.ts` / `constants.ts`
  - `*.service.ts` / `*.gateway.ts` / `*.controller.ts`
  - `*.test.ts` where applicable

Index/barrels:

- Each folder should have `index.ts` and use `export * from "./x"`.
- Avoid circular deps: barrels should export leaf modules, not re-export from other barrels.

---

## 6) Dependency + scaffolding rules

- Scaffold with official CLIs only; then **modify** generated files. Do not hand-create app/package configs (package.json, tsconfig, vite.config, etc.). Use `pnpm create vite`, `npx @nestjs/cli new`, `pnpm init`; for packages with no CLI, `pnpm init` then add minimal files (tsconfig, src/index.ts).
- Use pnpm for deps: `pnpm add`, `pnpm remove`, `pnpm up`. Keep same dependency versions in sync across apps/packages. Exception: adding **workspace** packages (e.g. `@chainfall/protocol`) may be done by editing package.json (`"workspace:*"`) then `pnpm install` if pnpm add fails; do not manually set versions for published packages.
- Prefer monorepo-wide commands (turbo/pnpm -w) over ad-hoc per-package hacks.

---

## 7) Security + correctness (high-level)

- Treat clients as untrusted. Server must validate every move/action.
- Keep game logic deterministic and replayable (implemented in `packages/game-core`).

---

## 8) AI VERIFICATION CHECKLIST (before proposing code)

Before you output code/changes, verify:

1. Did you keep the solution minimal (no extra layers)?
2. Did you follow kebab-case paths + short names?
3. Interfaces start with `I`; type aliases have no `T` prefix; no duplicate value-types.
4. Dependencies: pnpm only (or workspace edit + pnpm install if add fails).
5. Shared logic belongs in `packages/*`, not copied across apps.
6. Scaffolded with CLI then modified (no hand-created app/package configs).
7. Discriminants/fixed strings: const first, use it everywhere (no magic strings).
8. Derived types from consts live in the same file as the const.

If any check fails: STOP and fix.
